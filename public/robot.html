<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Robot Simulator (WS Signaling + WebRTC Sender)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      padding: 20px;
    }
    h1 { text-align:center; margin: 0 0 12px; font-size: 20px; }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #020617;
      border-radius: 16px;
      padding: 16px 20px 20px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      border: 1px solid #1f2937;
    }
    .row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px; align-items:center; }
    label { font-size: 0.85rem; color:#9ca3af; }
    input, select {
      background:#020617; color:#e5e7eb;
      border-radius:999px; border:1px solid #374151;
      padding:6px 10px; font-size:0.85rem; min-width:0;
    }
    input:focus, select:focus { outline:1px solid #4f46e5; border-color:#4f46e5; }
    button {
      border-radius:999px; border:none;
      padding:7px 14px; font-size:0.85rem;
      cursor:pointer; background:#4f46e5; color:white;
      display:inline-flex; align-items:center; gap:6px;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
    }
    button.secondary {
      background:#111827; color:#e5e7eb;
      border:1px solid #374151;
    }
    button.danger { background:#b91c1c; }
    button:disabled { opacity:0.4; cursor:default; transform:none; box-shadow:none; }

    .status-dot { display:inline-block; width:8px; height:8px; border-radius:999px; margin-right:6px; }
    .status-ok{background:#22c55e;} .status-bad{background:#ef4444;} .status-idle{background:#6b7280;}

    .status-bar { display:flex; gap:12px; font-size:0.8rem; color:#9ca3af; align-items:center; flex-wrap:wrap; }

    .grid {
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top: 12px;
    }
    .pane {
      background:#020617; border-radius:10px;
      padding:10px; border:1px solid #1f2937;
    }
    .pane h2 { font-size:0.85rem; margin:0 0 6px; color:#9ca3af; }
    video {
      width:100%; height:260px; background:#020617;
      border-radius:8px; border:1px solid #111827;
      object-fit:cover;
    }
    .logs {
      margin-top: 8px;
      background:#020617; border-radius:10px;
      padding:8px 10px; border:1px solid #111827;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:0.75rem; max-height:240px; overflow-y:auto; white-space:pre-wrap;
    }
    .small { font-size: 12px; color:#9ca3af; }
  </style>
</head>

<body>
  <h1>Robot Simulator (WebRTC → Unity)</h1>

  <div class="card">
    <div class="row">
      <label>WebSocket:</label>
      <input id="wsUrl" style="flex:1" />

      <label>robotId:</label>
      <input id="robotId" style="width: 160px" value="sim-robot-1"/>

      <label>STUN:</label>
      <input id="stunUrl" style="width: 240px" value="stun:stun.l.google.com:19302"/>

      <label>Streaming mode:</label>
      <select id="mode" style="width: 240px">
        <option value="webcam2d">1) webcam → 2D canvas</option>
        <option value="full360">2) 360 → skybox</option>
        <option value="crop360">3) cropped 360 → sphere (HFOV)</option>
      </select>

      <label>HFOV (crop):</label>
      <input id="hfov" style="width:121px" value="120"/>

      <label>VFOV (crop):</label>
      <input id="vfov" style="width:121px" value="121"/>
    </div>

    <div class="row">
      <button id="btnConnect">Connect WS</button>
      <button id="btnDisconnect" class="danger" disabled>Disconnect</button>

      <button id="btnStartMedia" class="secondary" disabled>Start / Apply Mode</button>
      <button id="btnStopAll" class="danger" disabled>Stop All</button>
      <span class="small">Start media, then select this robot in Unity.</span>
    </div>

    <div class="status-bar">
      <span id="wsStatus"><span class="status-dot status-idle"></span>WS: disconnected</span>
      <span id="pcStatus"><span class="status-dot status-idle"></span>WebRTC: idle</span>
      <span id="mediaStatus"><span class="status-dot status-idle"></span>Media: off</span>
      <span id="selStatus"></span>
    </div>

    <div class="grid">
      <div class="pane">
        <h2>Outgoing preview (what you send)</h2>
        <video id="preview" autoplay muted playsinline></video>
        <div class="logs" id="rawLog"></div>
      </div>

      <div class="pane">
        <h2>Controls received (server → robot)</h2>
        <div class="logs" id="controlsLog"></div>
      </div>

      <div class="pane">
        <h2>Signaling + viewport</h2>
        <div class="logs" id="sigLog"></div>
      </div>
    </div>
  </div>

<script>
  // ---------- UI ----------
  const wsUrlEl = document.getElementById("wsUrl");
  const robotIdEl = document.getElementById("robotId");
  const stunEl = document.getElementById("stunUrl");
  const modeEl = document.getElementById("mode");
  const hfovEl = document.getElementById("hfov");
  const vfovEl = document.getElementById("vfov");

  const btnConnect = document.getElementById("btnConnect");
  const btnDisconnect = document.getElementById("btnDisconnect");
  const btnStartMedia = document.getElementById("btnStartMedia");
  const btnStopAll = document.getElementById("btnStopAll");

  const wsStatusEl = document.getElementById("wsStatus");
  const pcStatusEl = document.getElementById("pcStatus");
  const mediaStatusEl = document.getElementById("mediaStatus");
  const selStatusEl = document.getElementById("selStatus");

  const rawLog = document.getElementById("rawLog");
  const controlsLog = document.getElementById("controlsLog");
  const sigLog = document.getElementById("sigLog");
  const preview = document.getElementById("preview");

  function setStatus(el, text, state) {
    const dot = el.querySelector(".status-dot");
    dot.className = "status-dot " + (state==="ok" ? "status-ok" : state==="bad" ? "status-bad" : "status-idle");
    el.childNodes[1].nodeValue = " " + text;
  }
  function log(el, msg) {
    const t = new Date().toLocaleTimeString();
    el.textContent += `[${t}] ${msg}\n`;
    el.scrollTop = el.scrollHeight;
  }
  function guessWsUrl() {
    const { protocol, host } = window.location;
    if (protocol === "https:") return `wss://${host}`;
    if (protocol === "http:") return `ws://${host}`;
    return "ws://localhost:3000";
  }
  wsUrlEl.value = guessWsUrl();

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // ---------- State ----------
  let ws = null;
  let pc = null;

  let mediaOpId = 0;
  let pendingOffer = null;

  let webcamStream = null;
  let video360El = null;

  let localStream = null;
  let videoSender = null;

  let cropCanvas = null;
  let cropCtx = null;
  let cropTimer = null;

  // viewport request from Unity (yaw/pitch)
  const viewport = { yawDeg: 0, pitchDeg: 0 };

  // stats
  let controlCount = 0;
  let lastControlAt = 0;

  function sendWs(obj) {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const s = JSON.stringify(obj);
    ws.send(s);
    log(rawLog, "WS -> " + s);
  }

  // ---------- WebRTC ----------
  function ensurePc() {
    if (pc) return;

    pc = new RTCPeerConnection({
      iceServers: [{ urls: [stunEl.value || "stun:stun.l.google.com:19302"] }]
    });

    pc.onicecandidate = (ev) => {
      if (!ev.candidate) return;
      sendWs({
        type: "candidate",
        candidate: ev.candidate.candidate,
        sdpMid: ev.candidate.sdpMid,
        sdpMLineIndex: ev.candidate.sdpMLineIndex
      });
      log(sigLog, "ICE -> candidate");
    };

    pc.onconnectionstatechange = () => {
      log(sigLog, "PC state = " + pc.connectionState);
      setStatus(pcStatusEl, "WebRTC: " + pc.connectionState, pc.connectionState === "connected" ? "ok" : "idle");
    };

    setStatus(pcStatusEl, "WebRTC: created", "ok");
  }

  async function handleOffer(msg) {
    ensurePc();

    if (!localStream) {
      log(sigLog, "Offer received before media. Queued until Start/Apply Mode.");
      pendingOffer = msg;
      return;
    }

    await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    sendWs({ type: "answer", sdp: pc.localDescription.sdp });
    log(sigLog, "Answer sent");
  }

  async function handleCandidate(msg) {
    if (!pc) return;
    try {
      await pc.addIceCandidate({
        candidate: msg.candidate,
        sdpMid: msg.sdpMid,
        sdpMLineIndex: msg.sdpMLineIndex
      });
      log(sigLog, "ICE <- candidate added");
    } catch (e) {
      log(sigLog, "addIceCandidate error: " + e.message);
    }
  }

  // ---------- Crop helpers ----------
  function stopCropLoop() {
    if (cropTimer) { clearInterval(cropTimer); cropTimer = null; }
    cropCanvas = null;
    cropCtx = null;
  }

  // NEW: output a full equirect (outW x outH) that is BLACK everywhere,
  // and copy only the requested viewport rectangle into the correct place.
  function startBlackEquirectWithViewport(videoEl, outW=2048, outH=1024, fps=30) {
    stopCropLoop();

    cropCanvas = document.createElement("canvas");
    cropCanvas.width = outW;
    cropCanvas.height = outH;
    cropCtx = cropCanvas.getContext("2d", { alpha: false });

    function draw() {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;

      const srcW = videoEl.videoWidth;
      const srcH = videoEl.videoHeight;

      const hfov = clamp(parseFloat(hfovEl.value || "120"), 10, 180);
      const vfov = clamp(parseFloat(vfovEl.value || "121"), 10, 120);

      // Fill with black (guarantees you see only updated region)
      cropCtx.fillStyle = "black";
      cropCtx.fillRect(0, 0, outW, outH);

      // Normalize yaw to [-180,180]
      let yaw = viewport.yawDeg;
      while (yaw < -180) yaw += 360;
      while (yaw > 180) yaw -= 360;

      const pitch = clamp(viewport.pitchDeg, -89, 89);

      // Source center in pixels
      const srcCx = (yaw + 180) / 360 * srcW;
      const srcCy = (121 - pitch) / 180 * srcH;

      const srcCropW = (hfov / 360) * srcW;
      const srcCropH = (vfov / 180) * srcH;

      let sx = srcCx - srcCropW / 2;
      let sy = srcCy - srcCropH / 2;
      sy = clamp(sy, 0, srcH - srcCropH);

      // Destination center in output equirect pixels
      const dstCx = (yaw + 180) / 360 * outW;
      const dstCy = (121 - pitch) / 180 * outH;

      const dstCropW = (hfov / 360) * outW;
      const dstCropH = (vfov / 180) * outH;

      let dx = dstCx - dstCropW / 2;
      let dy = dstCy - dstCropH / 2;
      dy = clamp(dy, 0, outH - dstCropH);

      // Wrap source X into [0,srcW)
      const sxNorm = ((sx % srcW) + srcW) % srcW;

      // Destination wrapping (dx can be negative)
      const dxNorm = ((dx % outW) + outW) % outW;

      // If neither wraps, draw once
      const srcWraps = (sxNorm + srcCropW > srcW);
      const dstWraps = (dxNorm + dstCropW > outW);

      if (!srcWraps && !dstWraps) {
        cropCtx.drawImage(videoEl, sxNorm, sy, srcCropW, srcCropH, dxNorm, dy, dstCropW, dstCropH);
        return;
      }

      // We split by angular ratio based on how much fits before wrap in SOURCE
      const srcLeftW = Math.min(srcCropW, srcW - sxNorm);
      const srcRightW = srcCropW - srcLeftW;

      const leftRatio = srcLeftW / srcCropW;
      const dstLeftW = dstCropW * leftRatio;
      const dstRightW = dstCropW - dstLeftW;

      // Draw left part
      cropCtx.drawImage(videoEl, sxNorm, sy, srcLeftW, srcCropH, dxNorm, dy, dstLeftW, dstCropH);

      // Draw right part (wraps around)
      if (srcRightW > 0.001) {
        cropCtx.drawImage(videoEl, 0, sy, srcRightW, srcCropH, 0, dy, dstRightW, dstCropH);
      }
    }

    cropTimer = setInterval(draw, 1000 / fps);
    return cropCanvas.captureStream(fps);
  }

  // ---------- Media control (race-safe) ----------
  async function stopMediaOnly(myOp=null) {
    stopCropLoop();

    if (webcamStream) {
      webcamStream.getTracks().forEach(t => t.stop());
      webcamStream = null;
    }
    if (video360El) {
      if (myOp === null || myOp === mediaOpId) {
        try { video360El.pause(); } catch {}
      }
      video360El = null;
    }

    localStream = null;
    preview.srcObject = null;

    setStatus(mediaStatusEl, "Media: off", "idle");
  }

  function sendUnityRenderMode() {
    const m = modeEl.value;
    let renderMode = "flat2d";
    if (m === "full360") renderMode = "full360";
    if (m === "crop360") renderMode = "crop360";
    if (m === "webcam2d") renderMode = "flat2d";

    sendWs({ type:"streamMode", mode: renderMode });
    log(sigLog, "Sent streamMode=" + renderMode);
  }

  async function applyModeAndStartMedia() {
    const myOp = ++mediaOpId;

    btnStartMedia.disabled = true;
    modeEl.disabled = true;

    try {
      await stopMediaOnly(myOp);
      if (myOp !== mediaOpId) return;

      ensurePc();

      const m = modeEl.value;

      if (m === "webcam2d") {
        webcamStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720, frameRate: 30 },
          audio: false
        });
        if (myOp !== mediaOpId) return;

        localStream = webcamStream;
        preview.srcObject = localStream;

        sendUnityRenderMode();
        setStatus(mediaStatusEl, "Media: webcam (2D)", "ok");
      }
      else {
        video360El = document.createElement("video");
        video360El.src = "/360.mp4";
        video360El.loop = true;
        video360El.muted = true;
        video360El.playsInline = true;

        await new Promise((resolve, reject) => {
          const onLoaded = () => { cleanup(); resolve(); };
          const onErr = () => { cleanup(); reject(new Error("Failed to load /360.mp4")); };
          const cleanup = () => {
            video360El.removeEventListener("loadedmetadata", onLoaded);
            video360El.removeEventListener("error", onErr);
          };
          video360El.addEventListener("loadedmetadata", onLoaded);
          video360El.addEventListener("error", onErr);
        });

        if (myOp !== mediaOpId) return;

        await video360El.play();
        if (myOp !== mediaOpId) return;

        if (m === "full360") {
          localStream = video360El.captureStream(30);
          preview.srcObject = localStream;

          sendUnityRenderMode();
          setStatus(mediaStatusEl, "Media: 360 (skybox)", "ok");
        } else { // crop360
          // IMPORTANT: stream a full equirect frame where everything else is black
          localStream = startBlackEquirectWithViewport(video360El, 2048, 1024, 30);
          preview.srcObject = localStream;

          sendUnityRenderMode();
          setStatus(mediaStatusEl, "Media: crop360 as black equirect", "ok");
        }
      }

      const track = localStream.getVideoTracks()[0];
      if (!track) throw new Error("No video track to send");

      if (!videoSender) {
        videoSender = pc.addTrack(track, localStream);
        log(sigLog, "addTrack(video)");
      } else {
        await videoSender.replaceTrack(track);
        log(sigLog, "replaceTrack(video)");
      }

      if (pendingOffer) {
        const offer = pendingOffer;
        pendingOffer = null;
        await handleOffer(offer);
      }

    } catch (e) {
      if (myOp === mediaOpId) {
        setStatus(mediaStatusEl, "Media: error", "bad");
        log(sigLog, "Media error: " + e.message);
      }
    } finally {
      if (myOp === mediaOpId) {
        btnStartMedia.disabled = false;
        modeEl.disabled = false;
      }
    }
  }

  // ---------- Cleanup ----------
  function cleanupAll() {
    pendingOffer = null;

    stopMediaOnly(null);
    setStatus(mediaStatusEl, "Media: off", "idle");

    if (pc) { try { pc.close(); } catch {} pc = null; }
    videoSender = null;
    setStatus(pcStatusEl, "WebRTC: idle", "idle");

    if (ws) { try { ws.close(); } catch {} ws = null; }
    setStatus(wsStatusEl, "WS: disconnected", "idle");

    selStatusEl.textContent = "";
    btnStartMedia.disabled = true;
    btnDisconnect.disabled = true;
    btnStopAll.disabled = true;
    btnConnect.disabled = false;

    log(sigLog, "Stopped all");
  }

  // ---------- WS connect ----------
  btnConnect.onclick = () => {
    if (ws && ws.readyState === WebSocket.OPEN) return;

    ws = new WebSocket(wsUrlEl.value.trim());
    ws.onopen = () => {
      setStatus(wsStatusEl, "WS: connected", "ok");
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;
      btnStartMedia.disabled = false;
      btnStopAll.disabled = false;

      sendWs({ type:"hello", role:"robot", robotId: robotIdEl.value.trim(), meta:{ name:"Browser Robot Sim" } });
      selStatusEl.textContent = `robotId: ${robotIdEl.value.trim()} | controls: 0 | last: ∞`;

      log(sigLog, "Connected. Start media, then select this robot in Unity.");
    };

    ws.onmessage = async (ev) => {
      log(rawLog, "WS <- " + ev.data);
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      if (msg.type === "control") {
        controlCount++;
        lastControlAt = Date.now();
        log(controlsLog, JSON.stringify(msg));
        return;
      }

      if (msg.type === "viewport") {
        if (typeof msg.yawDeg === "number") viewport.yawDeg = msg.yawDeg;
        if (typeof msg.pitchDeg === "number") viewport.pitchDeg = msg.pitchDeg;

        // let Unity drive crop FOV
        if (typeof msg.hfovDeg === "number") hfovEl.value = msg.hfovDeg;
        if (typeof msg.vfovDeg === "number") vfovEl.value = msg.vfovDeg;
        return;
      }

      if (msg.type === "offer") { log(sigLog, "Offer received"); await handleOffer(msg); return; }
      if (msg.type === "candidate") { await handleCandidate(msg); return; }

      if (msg.type === "hello_ok") { log(sigLog, "hello_ok"); return; }
    };

    ws.onerror = () => setStatus(wsStatusEl, "WS: error", "bad");
    ws.onclose = () => setStatus(wsStatusEl, "WS: disconnected", "idle");
  };

  btnDisconnect.onclick = () => {
    if (ws) { try { ws.close(); } catch {} ws = null; }
    setStatus(wsStatusEl, "WS: disconnected", "idle");
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
  };

  btnStartMedia.onclick = async () => { await applyModeAndStartMedia(); };
  btnStopAll.onclick = cleanupAll;

  // status freshness
  setInterval(() => {
    const ageMs = lastControlAt ? (Date.now() - lastControlAt) : null;
    const ageTxt = ageMs == null ? "∞" : (ageMs/1000).toFixed(2) + "s";
    selStatusEl.textContent = `robotId: ${robotIdEl.value.trim()} | controls: ${controlCount} | last: ${ageTxt}`;
  }, 250);

  window.addEventListener("beforeunload", () => cleanupAll());
</script>
</body>
</html>
