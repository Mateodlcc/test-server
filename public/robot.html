<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Robot Simulator (WS Signaling + WebRTC Sender)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      padding: 20px;
    }
    h1 { text-align:center; margin: 0 0 12px; font-size: 20px; }
    .card {
      max-width: 1200px;
      margin: 0 auto;
      background: #020617;
      border-radius: 16px;
      padding: 16px 20px 20px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.5);
      border: 1px solid #1f2937;
    }
    .row { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:10px; align-items:center; }
    label { font-size: 0.85rem; color:#9ca3af; }
    input, select {
      background:#020617; color:#e5e7eb;
      border-radius:999px; border:1px solid #374151;
      padding:6px 10px; font-size:0.85rem; min-width:0;
    }
    input:focus, select:focus { outline:1px solid #4f46e5; border-color:#4f46e5; }
    button {
      border-radius:999px; border:none;
      padding:7px 14px; font-size:0.85rem;
      cursor:pointer; background:#4f46e5; color:white;
      display:inline-flex; align-items:center; gap:6px;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
    }
    button.secondary {
      background:#111827; color:#e5e7eb;
      border:1px solid #374151;
    }
    button.danger { background:#b91c1c; }
    button:disabled { opacity:0.4; cursor:default; transform:none; box-shadow:none; }
    button:not(:disabled):active { transform: translateY(1px); }

    .status-dot { display:inline-block; width:8px; height:8px; border-radius:999px; margin-right:6px; }
    .status-ok{background:#22c55e;} .status-bad{background:#ef4444;} .status-idle{background:#6b7280;}

    .status-bar { display:flex; gap:12px; font-size:0.8rem; color:#9ca3af; align-items:center; flex-wrap:wrap; }

    .grid {
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top: 12px;
    }
    .pane {
      background:#020617; border-radius:10px;
      padding:10px; border:1px solid #1f2937;
    }
    .pane h2 { font-size:0.85rem; margin:0 0 6px; color:#9ca3af; }
    video {
      width:100%; height:260px; background:#020617;
      border-radius:8px; border:1px solid #111827;
      object-fit:cover;
    }
    .logs {
      margin-top: 8px;
      background:#020617; border-radius:10px;
      padding:8px 10px; border:1px solid #111827;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:0.75rem; max-height:240px; overflow-y:auto; white-space:pre-wrap;
    }
    .small { font-size: 12px; color:#9ca3af; }
  </style>
</head>

<body>
  <h1>Robot Simulator (WebRTC → Unity)</h1>

  <div class="card">
    <div class="row">
      <label>WebSocket:</label>
      <input id="wsUrl" style="flex:1" />

      <label>robotId:</label>
      <input id="robotId" style="width: 160px" value="sim-robot-1"/>

      <label>STUN:</label>
      <input id="stunUrl" style="width: 240px" value="stun:stun.l.google.com:19302"/>

      <label>Source:</label>
      <select id="source" style="width: 180px">
        <option value="webcam">Webcam</option>
        <option value="video360">Local 360 (/360.mp4)</option>
      </select>

      <label>Stream mode:</label>
      <select id="streamMode" style="width: 160px">
        <option value="full360">full360</option>
        <option value="viewport">viewport</option>
      </select>

      <label>HFOV:</label>
      <input id="hfov" style="width:90px" value="120"/>

      <label>VFOV:</label>
      <input id="vfov" style="width:90px" value="90"/>
    </div>

    <div class="row">
      <button id="btnConnect">Connect WS</button>
      <button id="btnDisconnect" class="danger" disabled>Disconnect</button>

      <button id="btnStartMedia" class="secondary" disabled>Start Media</button>
      <button id="btnSwitchSource" class="secondary" disabled>Switch Source</button>

      <button id="btnStopAll" class="danger" disabled>Stop All</button>
      <span class="small">Tip: start media before selecting robot in Unity for fastest first-connect.</span>
    </div>

    <div class="status-bar">
      <span id="wsStatus"><span class="status-dot status-idle"></span>WS: disconnected</span>
      <span id="pcStatus"><span class="status-dot status-idle"></span>WebRTC: idle</span>
      <span id="mediaStatus"><span class="status-dot status-idle"></span>Media: off</span>
      <span id="selStatus"></span>
    </div>

    <div class="grid">
      <div class="pane">
        <h2>Outgoing preview (what you send)</h2>
        <video id="preview" autoplay muted playsinline></video>
        <div class="logs" id="rawLog"></div>
      </div>

      <div class="pane">
        <h2>Controls received (server → robot, gated)</h2>
        <div class="logs" id="controlsLog"></div>
      </div>

      <div class="pane">
        <h2>Signaling (offer/answer/candidates + viewport)</h2>
        <div class="logs" id="sigLog"></div>
      </div>
    </div>
  </div>

<script>
  // ---------- UI ----------
  const wsUrlEl = document.getElementById("wsUrl");
  const robotIdEl = document.getElementById("robotId");
  const stunEl = document.getElementById("stunUrl");
  const sourceEl = document.getElementById("source");
  const streamModeEl = document.getElementById("streamMode");
  const hfovEl = document.getElementById("hfov");
  const vfovEl = document.getElementById("vfov");

  const btnConnect = document.getElementById("btnConnect");
  const btnDisconnect = document.getElementById("btnDisconnect");
  const btnStartMedia = document.getElementById("btnStartMedia");
  const btnSwitchSource = document.getElementById("btnSwitchSource");
  const btnStopAll = document.getElementById("btnStopAll");

  const wsStatusEl = document.getElementById("wsStatus");
  const pcStatusEl = document.getElementById("pcStatus");
  const mediaStatusEl = document.getElementById("mediaStatus");
  const selStatusEl = document.getElementById("selStatus");

  const rawLog = document.getElementById("rawLog");
  const controlsLog = document.getElementById("controlsLog");
  const sigLog = document.getElementById("sigLog");
  const preview = document.getElementById("preview");

  function setStatus(el, text, state) {
    const dot = el.querySelector(".status-dot");
    dot.className = "status-dot " + (state==="ok" ? "status-ok" : state==="bad" ? "status-bad" : "status-idle");
    el.childNodes[1].nodeValue = " " + text;
  }
  function log(el, msg) {
    const t = new Date().toLocaleTimeString();
    el.textContent += `[${t}] ${msg}\n`;
    el.scrollTop = el.scrollHeight;
  }
  function guessWsUrl() {
    const { protocol, host } = window.location;
    if (protocol === "https:") return `wss://${host}`;
    if (protocol === "http:") return `ws://${host}`;
    return "ws://localhost:3000";
  }
  wsUrlEl.value = guessWsUrl();

  // ---------- State ----------
  let ws = null;
  let pc = null;

  let localStream = null;     // preview stream (what we show in <video>)
  let localVideoEl = null;    // when source is /360.mp4 we keep a hidden <video>
  let webcamStream = null;

  let videoSender = null;     // RTCRtpSender for outgoing video
  let pendingOffer = null;    // queue offer if Unity offers before media is ready

  // viewport state (driven by Unity)
  const viewport = { yawDeg: 0, pitchDeg: 0, hfovDeg: 120, vfovDeg: 90 };

  // crop machinery (for viewport mode)
  let cropCanvas = null;
  let cropCtx = null;
  let cropTimer = null;

  // control stats
  let controlCount = 0;
  let lastControlAt = 0;

  function sendWs(obj) {
    if (!ws || ws.readyState !== WebSocket.OPEN) return;
    const s = JSON.stringify(obj);
    ws.send(s);
    log(rawLog, "WS -> " + s);
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // ---------- WebRTC ----------
  function ensurePc() {
    if (pc) return;

    pc = new RTCPeerConnection({
      iceServers: [{ urls: [stunEl.value || "stun:stun.l.google.com:19302"] }]
    });

    pc.onicecandidate = (ev) => {
      if (!ev.candidate) return;
      sendWs({
        type: "candidate",
        candidate: ev.candidate.candidate,
        sdpMid: ev.candidate.sdpMid,
        sdpMLineIndex: ev.candidate.sdpMLineIndex
      });
      log(sigLog, "ICE -> candidate");
    };

    pc.onconnectionstatechange = () => {
      log(sigLog, "PC state = " + pc.connectionState);
      setStatus(pcStatusEl, "WebRTC: " + pc.connectionState, pc.connectionState === "connected" ? "ok" : "idle");
    };

    setStatus(pcStatusEl, "WebRTC: created", "ok");
  }

  async function handleOffer(msg) {
    ensurePc();

    if (!localStream) {
      log(sigLog, "Offer received before media. Queued until Start Media.");
      pendingOffer = msg;
      return;
    }

    await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);

    sendWs({ type: "answer", sdp: pc.localDescription.sdp });
    log(sigLog, "Answer sent");
  }

  async function handleCandidate(msg) {
    if (!pc) return;
    try {
      await pc.addIceCandidate({
        candidate: msg.candidate,
        sdpMid: msg.sdpMid,
        sdpMLineIndex: msg.sdpMLineIndex
      });
      log(sigLog, "ICE <- candidate added");
    } catch (e) {
      log(sigLog, "addIceCandidate error: " + e.message);
    }
  }

  // ---------- Viewport crop ----------
  function stopCropLoop() {
    if (cropTimer) { clearInterval(cropTimer); cropTimer = null; }
    cropCanvas = null;
    cropCtx = null;
  }

  function startViewportCropFromEquirectVideo(videoEl, outW = 1280, outH = 720, fps = 30) {
    stopCropLoop();

    cropCanvas = document.createElement("canvas");
    cropCanvas.width = outW;
    cropCanvas.height = outH;
    cropCtx = cropCanvas.getContext("2d", { alpha: false });

    function draw() {
      if (!videoEl.videoWidth || !videoEl.videoHeight) return;

      const W = videoEl.videoWidth;
      const H = videoEl.videoHeight;

      // pull latest requested fov from UI (robot-side override) if present
      const hfov = clamp(parseFloat(hfovEl.value || "120"), 10, 180);
      const vfov = clamp(parseFloat(vfovEl.value || "90"), 10, 120);

      viewport.hfovDeg = hfov;
      viewport.vfovDeg = vfov;

      // yaw [-180,180] -> x [0,W)
      let yaw = viewport.yawDeg;
      while (yaw < -180) yaw += 360;
      while (yaw > 180) yaw -= 360;
      const cx = (yaw + 180) / 360 * W;

      // pitch [-90,90] -> y [0,H)
      const pitch = clamp(viewport.pitchDeg, -89, 89);
      const cy = (90 - pitch) / 180 * H;

      const cropW = (hfov / 360) * W;
      const cropH = (vfov / 180) * H;

      // top-left
      let sx = cx - cropW / 2;
      let sy = cy - cropH / 2;

      // clamp vertical
      sy = clamp(sy, 0, H - cropH);

      // clear
      cropCtx.fillRect(0, 0, outW, outH);

      // horizontal wrap
      if (sx >= 0 && sx + cropW <= W) {
        cropCtx.drawImage(videoEl, sx, sy, cropW, cropH, 0, 0, outW, outH);
      } else {
        const sxNorm = ((sx % W) + W) % W; // bring into [0,W)
        const leftW = Math.min(cropW, W - sxNorm);
        const rightW = cropW - leftW;

        if (leftW > 0) {
          cropCtx.drawImage(videoEl, sxNorm, sy, leftW, cropH, 0, 0, outW * (leftW / cropW), outH);
        }
        if (rightW > 0) {
          cropCtx.drawImage(videoEl, 0, sy, rightW, cropH, outW * (leftW / cropW), 0, outW * (rightW / cropW), outH);
        }
      }
    }

    cropTimer = setInterval(draw, 1000 / fps);
    return cropCanvas.captureStream(fps);
  }

  // ---------- Media start / switching ----------
  async function stopAllMediaOnly() {
    stopCropLoop();

    if (webcamStream) {
      webcamStream.getTracks().forEach(t => t.stop());
      webcamStream = null;
    }
    if (localVideoEl) {
      try { localVideoEl.pause(); } catch {}
      localVideoEl = null;
    }
    localStream = null;
    preview.srcObject = null;

    setStatus(mediaStatusEl, "Media: off", "idle");
  }

  async function ensureMediaForSelectedSource() {
    await stopAllMediaOnly();

    if (sourceEl.value === "webcam") {
      webcamStream = await navigator.mediaDevices.getUserMedia({
        video: { width: 1280, height: 720, frameRate: 30 },
        audio: false
      });
      localStream = webcamStream;
      preview.srcObject = localStream;

      setStatus(mediaStatusEl, "Media: webcam", "ok");

      // tell Unity how to render webcam (treat as flat)
      sendWs({ type: "streamMode", mode: "viewport" }); // webcam is not panoramic; use viewport dome or 2D on Unity side
      log(sigLog, "Sent streamMode=viewport (webcam)");
      return;
    }

    // 360 video source
    localVideoEl = document.createElement("video");
    localVideoEl.src = "/360.mp4";
    localVideoEl.loop = true;
    localVideoEl.muted = true;
    localVideoEl.playsInline = true;

    await localVideoEl.play();

    // initial mode
    await rebuildOutgoingVideoTrack();

    setStatus(mediaStatusEl, "Media: 360 video", "ok");
  }

  async function rebuildOutgoingVideoTrack() {
    if (!pc) ensurePc();

    // stop old crop loop if any
    stopCropLoop();

    let newStream = null;

    if (sourceEl.value === "webcam") {
      // webcam: just stream webcam
      if (!webcamStream) return;
      newStream = webcamStream;

      // Webcam isn't 360; have Unity render as viewport/2D
      sendWs({ type:"streamMode", mode:"viewport" });
      log(sigLog, "streamMode -> viewport (webcam)");
    }
    else {
      if (!localVideoEl) return;

      const mode = streamModeEl.value;

      if (mode === "full360") {
        newStream = localVideoEl.captureStream(30);
        sendWs({ type:"streamMode", mode:"full360" });
        log(sigLog, "streamMode -> full360");
      } else {
        newStream = startViewportCropFromEquirectVideo(localVideoEl, 1280, 720, 30);
        sendWs({ type:"streamMode", mode:"viewport" });
        log(sigLog, "streamMode -> viewport");
      }
    }

    if (!newStream) return;

    const newTrack = newStream.getVideoTracks()[0];
    if (!newTrack) return;

    if (!videoSender) {
      // First time: addTrack
      videoSender = pc.addTrack(newTrack, newStream);
      log(sigLog, "addTrack(video)");
    } else {
      // Hot swap
      await videoSender.replaceTrack(newTrack);
      log(sigLog, "replaceTrack(video)");
    }

    // local preview should match what we are sending
    localStream = newStream;
    preview.srcObject = localStream;

    // If Unity offered earlier, answer now
    if (pendingOffer) {
      const offer = pendingOffer;
      pendingOffer = null;
      await handleOffer(offer);
    }
  }

  // ---------- Cleanup ----------
  function cleanupAll() {
    pendingOffer = null;

    stopAllMediaOnly();
    setStatus(mediaStatusEl, "Media: off", "idle");

    if (pc) { try { pc.close(); } catch {} pc = null; }
    videoSender = null;
    setStatus(pcStatusEl, "WebRTC: idle", "idle");

    if (ws) { try { ws.close(); } catch {} ws = null; }
    setStatus(wsStatusEl, "WS: disconnected", "idle");

    selStatusEl.textContent = "";
    btnStartMedia.disabled = true;
    btnSwitchSource.disabled = true;
    btnDisconnect.disabled = true;
    btnStopAll.disabled = true;
    btnConnect.disabled = false;

    log(sigLog, "Stopped all");
  }

  // ---------- WS connect ----------
  btnConnect.onclick = () => {
    if (ws && ws.readyState === WebSocket.OPEN) return;

    ws = new WebSocket(wsUrlEl.value.trim());
    ws.onopen = () => {
      setStatus(wsStatusEl, "WS: connected", "ok");
      btnConnect.disabled = true;
      btnDisconnect.disabled = false;
      btnStartMedia.disabled = false;
      btnSwitchSource.disabled = false;
      btnStopAll.disabled = false;

      // hello robot
      sendWs({ type:"hello", role:"robot", robotId: robotIdEl.value.trim(), meta:{ name:"Browser Robot Sim" } });
      selStatusEl.textContent = `robotId: ${robotIdEl.value.trim()} | controls: 0 | last: ∞`;

      log(sigLog, "Connected. Waiting for offer… (select this robot in Unity)");
    };

    ws.onmessage = async (ev) => {
      log(rawLog, "WS <- " + ev.data);
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }

      // --- gated controls from headset ---
      if (msg.type === "control") {
        controlCount++;
        lastControlAt = Date.now();
        log(controlsLog, JSON.stringify(msg));
        return;
      }

      // --- viewport from headset (for crop mode) ---
      if (msg.type === "viewport") {
        viewport.yawDeg = msg.yawDeg ?? viewport.yawDeg;
        viewport.pitchDeg = msg.pitchDeg ?? viewport.pitchDeg;
        viewport.hfovDeg = msg.hfovDeg ?? viewport.hfovDeg;
        viewport.vfovDeg = msg.vfovDeg ?? viewport.vfovDeg;
        log(sigLog, `Viewport <- yaw=${viewport.yawDeg.toFixed(1)} pitch=${viewport.pitchDeg.toFixed(1)} hfov=${viewport.hfovDeg} vfov=${viewport.vfovDeg}`);
        return;
      }

      // --- signaling ---
      if (msg.type === "offer") { log(sigLog, "Offer received"); await handleOffer(msg); return; }
      if (msg.type === "candidate") { await handleCandidate(msg); return; }

      // --- optional ack ---
      if (msg.type === "hello_ok") { log(sigLog, "hello_ok"); return; }
    };

    ws.onerror = () => setStatus(wsStatusEl, "WS: error", "bad");
    ws.onclose = () => setStatus(wsStatusEl, "WS: disconnected", "idle");
  };

  btnDisconnect.onclick = () => {
    if (ws) { try { ws.close(); } catch {} ws = null; }
    setStatus(wsStatusEl, "WS: disconnected", "idle");
    btnConnect.disabled = false;
    btnDisconnect.disabled = true;
  };

  btnStartMedia.onclick = async () => {
    try {
      await ensureMediaForSelectedSource();
      log(sigLog, "Media started: " + sourceEl.value);
    } catch (e) {
      setStatus(mediaStatusEl, "Media: error", "bad");
      log(sigLog, "Media error: " + e.message);
    }
  };

  btnSwitchSource.onclick = async () => {
    sourceEl.value = (sourceEl.value === "webcam") ? "video360" : "webcam";
    await ensureMediaForSelectedSource();
    log(sigLog, "Switched source to: " + sourceEl.value);
  };

  btnStopAll.onclick = cleanupAll;

  // change stream mode live (only affects 360 source)
  streamModeEl.onchange = async () => {
    log(sigLog, "Mode changed -> " + streamModeEl.value);
    await rebuildOutgoingVideoTrack();
  };

  // update local crop fov immediately
  hfovEl.onchange = async () => { if (streamModeEl.value === "viewport") await rebuildOutgoingVideoTrack(); };
  vfovEl.onchange = async () => { if (streamModeEl.value === "viewport") await rebuildOutgoingVideoTrack(); };

  // update status (control freshness)
  setInterval(() => {
    const ageMs = lastControlAt ? (Date.now() - lastControlAt) : null;
    const ageTxt = ageMs == null ? "∞" : (ageMs/1000).toFixed(2) + "s";
    selStatusEl.textContent = `robotId: ${robotIdEl.value.trim()} | controls: ${controlCount} | last: ${ageTxt}`;
  }, 250);

  window.addEventListener("beforeunload", () => cleanupAll());
</script>
</body>
</html>
